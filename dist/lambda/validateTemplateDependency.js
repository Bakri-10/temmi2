"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AWS = require("aws-sdk");
const s3 = new AWS.S3();
const client_s3_1 = require("@aws-sdk/client-s3");
const dynamodb = new AWS.DynamoDB();
const s3Client = new client_s3_1.S3Client();
const unzipper = require("unzipper");
const compare_versions_1 = require("compare-versions");
const cchLambdaLogger_js_1 = require("./cchLambdaLogger.js");
async function getTemplate(event) {
    const s3key = event.template.folder + '/' + event.template.file;
    const bucketParams = {
        Bucket: event.template.bucket,
        Key: s3key
    };
    cchLambdaLogger.log('Calling get template');
    const data = await s3.getObject(bucketParams).promise();
    const output = data.Body.toString();
    return JSON.parse(output);
}
async function streamToString(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on('error', (err) => reject(err));
        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    });
}
async function getAppPackage(appSourceLocations) {
    let firstIndex = appSourceLocations.indexOf("/");
    let s3Params = {
        Key: appSourceLocations.slice(firstIndex + 1),
        Bucket: appSourceLocations.slice(0, firstIndex)
    };
    const getObjectResponse = await s3Client.send(new client_s3_1.GetObjectCommand(s3Params));
    const file_stream = getObjectResponse.Body;
    file_stream.on("error", (e) => {
        cchLambdaLogger.error(e);
        throw e;
    });
    let _package;
    try {
        const packagejson = file_stream.pipe(unzipper.ParseOne("^package.json", { forceStream: true, }));
        const result = await streamToString(packagejson);
        cchLambdaLogger.log('getAppPackage success');
        _package = JSON.parse(result);
    }
    catch (_a) {
        //CCHLambdaLogger.log("Couldn't open package.json");
        throw new Error("Couldn't open package.json");
    }
    return new Promise((resolve, reject) => {
        if (_package !== undefined) {
            resolve(_package);
        }
        else {
            reject("Couldn't open package.json");
        }
    });
}
var cchLambdaLogger;
exports.handler = async (event, context) => {
    cchLambdaLogger = new cchLambdaLogger_js_1.CCHLambdaLogger(process.env.STAGE_PREFIX, process.env.REGION, process.env.ACCOUNT, process.env.CCH_VERSION, context, process.env.KINESIS_ENABLED, event.input.customer.customerPrefix, event.input.customer.zone, '', '', event.input.custom.FCCH.FCCH_Execution, event.input.custom.FCCH.FCCH_Input['producer-id']);
    cchLambdaLogger.log("Inside validateTemplateDependency lambda", event);
    const _data = await getTemplate(event);
    //get the number of stages to be iterated through later
    const numOfStages = _data.stages.length;
    let appSourceLocations = [];
    //number of tasks per stage
    let appsFromTemplate = [];
    let taskApp;
    let version;
    let taskCommand;
    let sourceLocation;
    //loop through each stage to get the tasks
    for (let i = 0; i < numOfStages; i++) {
        let taskPerStage = _data.stages[i].tasks.length;
        //loop through each task to get get its dependencies
        for (let j = 0; j < taskPerStage; j++) {
            try {
                let task = _data.stages[i].tasks[j];
                taskApp = task.params.app;
                version = task.params.version;
                taskCommand = task.params.command;
                appsFromTemplate.push({ [taskApp]: version });
                //build a composite key of app and command
                let compositeKey = taskApp.concat("#", taskCommand);
                cchLambdaLogger.log('compositeKey', compositeKey);
                let dbparams = {
                    Key: {
                        pk: {
                            S: "TASK"
                        },
                        sk: {
                            S: compositeKey
                        }
                    },
                    //Change tableName to a variable
                    TableName: process.env.STAGE_PREFIX + "-fcn-vending-task-definition"
                };
                let dynamoOutput = await dynamodb.getItem(dbparams).promise();
                sourceLocation = dynamoOutput.Item.appDefinition.M.execution.M.sourceLocation.S;
                appSourceLocations.push(sourceLocation.replace("${version}", version));
            }
            catch (error) {
                cchLambdaLogger.error(error);
                cchLambdaLogger.error(`sourceLocation lookup for ${taskApp} in db table failed.`);
            }
        }
    }
    let templateValidation = [];
    let dependencyList;
    //check dependencies from each apps package.json against the apps in the template
    cchLambdaLogger.log('Source locations to be called', appSourceLocations);
    //for each sourcelocation get the package.json
    for (let i = 0; i < appSourceLocations.length; i++) {
        let packagejson = await getAppPackage(appSourceLocations[i]);
        dependencyList = [];
        //check package.json has fineos.dependencies
        if ('dependencies' in packagejson.fineos) {
            let installerDependency = packagejson.fineos.dependencies;
            for (const key in installerDependency) {
                //if dependency is not in template add it to the missing list
                let checkKeyExists = key => appsFromTemplate.some(obj => Object.keys(obj).includes(key));
                let findIndexOfKey = key => appsFromTemplate.findIndex(obj => Object.keys(obj) == key);
                //if dependency from package.json is NOT in apps from template
                if (!(checkKeyExists(key))) {
                    cchLambdaLogger.log('Dependency not found in template', key, installerDependency[key]);
                    dependencyList.push({ "name": key, "version": installerDependency[key], "template": "-", "result": "missing" });
                }
                else if (checkKeyExists(key)) {
                    //if dependency from package.json is in template 
                    //index is the position of the dependency from package.json in the apps from template 
                    let index = findIndexOfKey(key);
                    //if position of index is after position of app in template count as missing dependency
                    if (!(index < i)) {
                        cchLambdaLogger.log(appsFromTemplate[index][key], ' appears in template after', key);
                        dependencyList.push({ "name": key, "version": installerDependency[key], "template": appsFromTemplate[index][key], "result": "order error" });
                    }
                    else {
                        //if dependency is in template and appears before app in template check for semantic versioning 
                        if ((0, compare_versions_1.satisfies)(appsFromTemplate[index][key], installerDependency[key]) === false) {
                            cchLambdaLogger.log('dependency is in template and does not satisfy semantic versioning', key, appsFromTemplate[index][key]);
                            dependencyList.push({ "name": key, "version": installerDependency[key], "template": appsFromTemplate[index][key], "result": "version error" });
                        }
                        else if ((0, compare_versions_1.satisfies)(appsFromTemplate[index][key], installerDependency[key]) === true) {
                            cchLambdaLogger.log('dependency exists and satisfies semver', appsFromTemplate[index][key], installerDependency[key]);
                            dependencyList.push({ "name": key, "version": installerDependency[key], "template": appsFromTemplate[index][key], "result": "pass" });
                        }
                    }
                }
            }
        }
        let appFromTemplate = Object.keys(appsFromTemplate[i]);
        templateValidation.push({ "name": appFromTemplate[0], "dependencies": dependencyList });
        // Needs to be in the following format to be processed by TOF correctly:
        // [
        //     {
        //         "name": "sample-app",
        //         "dependencies": dependencyList
        //     },
        //     {
        //         "name": "sample-app2",
        //         "dependencies": dependencyList
        //     }
        // ]
    }
    cchLambdaLogger.log('Missing dependencies are', templateValidation);
    return templateValidation;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGVUZW1wbGF0ZURlcGVuZGVuY3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9sYW1iZGEvdmFsaWRhdGVUZW1wbGF0ZURlcGVuZGVuY3kuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsTUFBTSxFQUFFLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDeEIsa0RBRzZCO0FBQzVCLE1BQU0sUUFBUSxHQUFHLElBQUksR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQ3BDLE1BQU0sUUFBUSxHQUFHLElBQUksb0JBQVEsRUFBRSxDQUFDO0FBQ2pDLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNyQyx1REFBNkM7QUFDN0MsNkRBQXVEO0FBRXZELEtBQUssVUFBVSxXQUFXLENBQUMsS0FBSztJQUM1QixNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7SUFDaEUsTUFBTSxZQUFZLEdBQUc7UUFDakIsTUFBTSxFQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTTtRQUM5QixHQUFHLEVBQUUsS0FBSztLQUNiLENBQUM7SUFDRixlQUFlLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQUE7SUFDM0MsTUFBTSxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3hELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFJRCxLQUFLLFVBQVUsY0FBYyxDQUFDLE1BQU07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Q0FBQyxDQUFBO0lBQ25FLE9BQU8sa0JBQWtCLENBQUE7QUFDN0IsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVdTID0gcmVxdWlyZShcImF3cy1zZGtcIik7XG5jb25zdCBzMyA9IG5ldyBBV1MuUzMoKTtcbmltcG9ydCB7XG4gICAgUzNDbGllbnQsXG4gICAgR2V0T2JqZWN0Q29tbWFuZFxuICB9IGZyb20gXCJAYXdzLXNkay9jbGllbnQtczNcIlxuIGNvbnN0IGR5bmFtb2RiID0gbmV3IEFXUy5EeW5hbW9EQigpO1xuIGNvbnN0IHMzQ2xpZW50ID0gbmV3IFMzQ2xpZW50KCk7XG5jb25zdCB1bnppcHBlciA9IHJlcXVpcmUoXCJ1bnppcHBlclwiKTtcbmltcG9ydCB7IHNhdGlzZmllcyB9IGZyb20gXCJjb21wYXJlLXZlcnNpb25zXCI7XG5pbXBvcnQgeyBDQ0hMYW1iZGFMb2dnZXIgfSBmcm9tIFwiLi9jY2hMYW1iZGFMb2dnZXIuanNcIjtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0VGVtcGxhdGUoZXZlbnQpIHtcbiAgICBjb25zdCBzM2tleSA9IGV2ZW50LnRlbXBsYXRlLmZvbGRlciArICcvJyArIGV2ZW50LnRlbXBsYXRlLmZpbGU7XG4gICAgY29uc3QgYnVja2V0UGFyYW1zID0ge1xuICAgICAgICBCdWNrZXQgOiBldmVudC50ZW1wbGF0ZS5idWNrZXQsXG4gICAgICAgIEtleTogczNrZXlcbiAgICB9O1xuICAgIGNjaExhbWJkYUxvZ2dlci5sb2coJ0NhbGxpbmcgZ2V0IHRlbXBsYXRlJylcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgczMuZ2V0T2JqZWN0KGJ1Y2tldFBhcmFtcykucHJvbWlzZSgpOyBcbiAgICBjb25zdCBvdXRwdXQgPSBkYXRhLkJvZHkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShvdXRwdXQpO1xufVxuXG5cblxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9TdHJpbmcoc3RyZWFtKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIChjaHVuaykgPT4gY2h1bmtzLnB1c2goQnVmZmVyLmZyb20oY2h1bmspKSk7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGVycikgPT4gcmVqZWN0KGVycikpO1xuICAgICAgc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKEJ1ZmZlci5jb25jYXQoY2h1bmtzKS50b1N0cmluZygndXRmOCcpKSk7XG4gICAgfSlcbiAgfVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBcHBQYWNrYWdlKGFwcFNvdXJjZUxvY2F0aW9ucyl7XG4gICAgbGV0IGZpcnN0SW5kZXggPSBhcHBTb3VyY2VMb2NhdGlvbnMuaW5kZXhPZihcIi9cIik7XG4gICAgbGV0IHMzUGFyYW1zID0ge1xuICAgICAgICBLZXk6IGFwcFNvdXJjZUxvY2F0aW9ucy5zbGljZShmaXJzdEluZGV4ICsgMSksXG4gICAgICAgIEJ1Y2tldDogYXBwU291cmNlTG9jYXRpb25zLnNsaWNlKDAsIGZpcnN0SW5kZXgpXG4gICAgfVxuICAgIGNvbnN0IGdldE9iamVjdFJlc3BvbnNlID0gYXdhaXQgczNDbGllbnQuc2VuZChuZXcgR2V0T2JqZWN0Q29tbWFuZChzM1BhcmFtcykpO1xuICAgIGNvbnN0IGZpbGVfc3RyZWFtID0gZ2V0T2JqZWN0UmVzcG9uc2UuQm9keTtcbiAgICBmaWxlX3N0cmVhbS5vbihcImVycm9yXCIsIChlKSA9PiB7XG4gICAgICAgIGNjaExhbWJkYUxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9KVxuICAgIGxldCBfcGFja2FnZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYWNrYWdlanNvbiA9IGZpbGVfc3RyZWFtLnBpcGUodW56aXBwZXIuUGFyc2VPbmUoXCJecGFja2FnZS5qc29uXCIsIHtmb3JjZVN0cmVhbTogdHJ1ZSx9KSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0cmVhbVRvU3RyaW5nKHBhY2thZ2Vqc29uKTtcbiAgICAgICAgY2NoTGFtYmRhTG9nZ2VyLmxvZygnZ2V0QXBwUGFja2FnZSBzdWNjZXNzJylcbiAgICAgICAgX3BhY2thZ2UgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjYXRjaCB7XG4gICAgICAgIC8vQ0NITGFtYmRhTG9nZ2VyLmxvZyhcIkNvdWxkbid0IG9wZW4gcGFja2FnZS5qc29uXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBvcGVuIHBhY2thZ2UuanNvblwiKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgaWYgKF9wYWNrYWdlICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHJlc29sdmUoX3BhY2thZ2UpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KFwiQ291bGRuJ3Qgb3BlbiBwYWNrYWdlLmpzb25cIilcbiAgICAgICAgfVxuICAgICAgfSlcbn1cblxudmFyIGNjaExhbWJkYUxvZ2dlcjtcbmV4cG9ydHMuaGFuZGxlciA9IGFzeW5jIChldmVudCwgY29udGV4dCkgPT4ge1xuXG4gICAgY2NoTGFtYmRhTG9nZ2VyID0gbmV3IENDSExhbWJkYUxvZ2dlcihwcm9jZXNzLmVudi5TVEFHRV9QUkVGSVgsIHByb2Nlc3MuZW52LlJFR0lPTiwgcHJvY2Vzcy5lbnYuQUNDT1VOVCwgXG4gICAgICAgIHByb2Nlc3MuZW52LkNDSF9WRVJTSU9OLCBjb250ZXh0LCBwcm9jZXNzLmVudi5LSU5FU0lTX0VOQUJMRUQsIGV2ZW50LmlucHV0LmN1c3RvbWVyLmN1c3RvbWVyUHJlZml4LCBcbiAgICAgICAgZXZlbnQuaW5wdXQuY3VzdG9tZXIuem9uZSwgJycsICcnLCBldmVudC5pbnB1dC5jdXN0b20uRkNDSC5GQ0NIX0V4ZWN1dGlvbiwgZXZlbnQuaW5wdXQuY3VzdG9tLkZDQ0guRkNDSF9JbnB1dFsncHJvZHVjZXItaWQnXSk7XG4gICAgXG4gICAgY2NoTGFtYmRhTG9nZ2VyLmxvZyhcIkluc2lkZSB2YWxpZGF0ZVRlbXBsYXRlRGVwZW5kZW5jeSBsYW1iZGFcIiwgZXZlbnQpO1xuXG4gICAgY29uc3QgX2RhdGEgPSBhd2FpdCBnZXRUZW1wbGF0ZShldmVudCkgXG4gICAgLy9nZXQgdGhlIG51bWJlciBvZiBzdGFnZXMgdG8gYmUgaXRlcmF0ZWQgdGhyb3VnaCBsYXRlclxuICAgIGNvbnN0IG51bU9mU3RhZ2VzID0gX2RhdGEuc3RhZ2VzLmxlbmd0aDtcbiAgICBsZXQgYXBwU291cmNlTG9jYXRpb25zID0gW107XG4gICAgLy9udW1iZXIgb2YgdGFza3MgcGVyIHN0YWdlXG4gICAgbGV0IGFwcHNGcm9tVGVtcGxhdGUgPSBbXTtcbiAgICBsZXQgdGFza0FwcDtcbiAgICBsZXQgdmVyc2lvbjtcbiAgICBsZXQgdGFza0NvbW1hbmQ7XG4gICAgbGV0IHNvdXJjZUxvY2F0aW9uO1xuICAgIFxuICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggc3RhZ2UgdG8gZ2V0IHRoZSB0YXNrc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZTdGFnZXM7IGkrKykge1xuICAgICAgICBsZXQgdGFza1BlclN0YWdlID0gX2RhdGEuc3RhZ2VzW2ldLnRhc2tzLmxlbmd0aFxuICAgICAgICBcbiAgICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCB0YXNrIHRvIGdldCBnZXQgaXRzIGRlcGVuZGVuY2llc1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhc2tQZXJTdGFnZTsgaisrKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgbGV0IHRhc2sgPSBfZGF0YS5zdGFnZXNbaV0udGFza3Nbal1cbiAgICAgICAgICAgICAgICB0YXNrQXBwID0gdGFzay5wYXJhbXMuYXBwO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB0YXNrLnBhcmFtcy52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIHRhc2tDb21tYW5kID0gdGFzay5wYXJhbXMuY29tbWFuZDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhcHBzRnJvbVRlbXBsYXRlLnB1c2goe1t0YXNrQXBwXTogdmVyc2lvbn0pXG4gICAgICAgICAgICAgICAgLy9idWlsZCBhIGNvbXBvc2l0ZSBrZXkgb2YgYXBwIGFuZCBjb21tYW5kXG5cbiAgICAgICAgICAgICAgICBsZXQgY29tcG9zaXRlS2V5ID0gdGFza0FwcC5jb25jYXQoXCIjXCIsIHRhc2tDb21tYW5kKTtcbiAgICAgICAgICAgICAgICBjY2hMYW1iZGFMb2dnZXIubG9nKCdjb21wb3NpdGVLZXknLCBjb21wb3NpdGVLZXkpXG5cbiAgICAgICAgICAgICAgICBsZXQgZGJwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGs6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTOiBcIlRBU0tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUzogY29tcG9zaXRlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vQ2hhbmdlIHRhYmxlTmFtZSB0byBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgIFRhYmxlTmFtZTogcHJvY2Vzcy5lbnYuU1RBR0VfUFJFRklYICsgXCItZmNuLXZlbmRpbmctdGFzay1kZWZpbml0aW9uXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxldCBkeW5hbW9PdXRwdXQgPSBhd2FpdCBkeW5hbW9kYi5nZXRJdGVtKGRicGFyYW1zKS5wcm9taXNlKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNvdXJjZUxvY2F0aW9uID0gZHluYW1vT3V0cHV0Lkl0ZW0uYXBwRGVmaW5pdGlvbi5NLmV4ZWN1dGlvbi5NLnNvdXJjZUxvY2F0aW9uLlM7XG4gICAgICAgICAgICAgICAgYXBwU291cmNlTG9jYXRpb25zLnB1c2goc291cmNlTG9jYXRpb24ucmVwbGFjZShcIiR7dmVyc2lvbn1cIiwgdmVyc2lvbikpXG4gICAgICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xuICAgICAgICAgICAgICAgIGNjaExhbWJkYUxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgY2NoTGFtYmRhTG9nZ2VyLmVycm9yKGBzb3VyY2VMb2NhdGlvbiBsb29rdXAgZm9yICR7dGFza0FwcH0gaW4gZGIgdGFibGUgZmFpbGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICAgXG4gICAgfVxuXG4gICAgXG4gICAgbGV0IHRlbXBsYXRlVmFsaWRhdGlvbiA9W107XG4gICAgbGV0IGRlcGVuZGVuY3lMaXN0O1xuICAgIC8vY2hlY2sgZGVwZW5kZW5jaWVzIGZyb20gZWFjaCBhcHBzIHBhY2thZ2UuanNvbiBhZ2FpbnN0IHRoZSBhcHBzIGluIHRoZSB0ZW1wbGF0ZVxuICAgIGNjaExhbWJkYUxvZ2dlci5sb2coJ1NvdXJjZSBsb2NhdGlvbnMgdG8gYmUgY2FsbGVkJywgYXBwU291cmNlTG9jYXRpb25zKVxuICAgIC8vZm9yIGVhY2ggc291cmNlbG9jYXRpb24gZ2V0IHRoZSBwYWNrYWdlLmpzb25cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgYXBwU291cmNlTG9jYXRpb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IHBhY2thZ2Vqc29uID0gYXdhaXQgZ2V0QXBwUGFja2FnZShhcHBTb3VyY2VMb2NhdGlvbnNbaV0pO1xuICAgICAgICBkZXBlbmRlbmN5TGlzdCA9IFtdO1xuICAgICAgICAvL2NoZWNrIHBhY2thZ2UuanNvbiBoYXMgZmluZW9zLmRlcGVuZGVuY2llc1xuICAgICAgICBpZiAoJ2RlcGVuZGVuY2llcycgaW4gcGFja2FnZWpzb24uZmluZW9zKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFsbGVyRGVwZW5kZW5jeSA9IHBhY2thZ2Vqc29uLmZpbmVvcy5kZXBlbmRlbmNpZXNcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbGxlckRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAvL2lmIGRlcGVuZGVuY3kgaXMgbm90IGluIHRlbXBsYXRlIGFkZCBpdCB0byB0aGUgbWlzc2luZyBsaXN0XG4gICAgICAgICAgICAgICAgbGV0IGNoZWNrS2V5RXhpc3RzID0ga2V5ID0+IGFwcHNGcm9tVGVtcGxhdGUuc29tZShvYmogPT4gT2JqZWN0LmtleXMob2JqKS5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGxldCBmaW5kSW5kZXhPZktleSA9IGtleSA9PiBhcHBzRnJvbVRlbXBsYXRlLmZpbmRJbmRleChvYmogPT4gT2JqZWN0LmtleXMob2JqKSA9PSBrZXkpXG4gICAgICAgICAgICAgICAgLy9pZiBkZXBlbmRlbmN5IGZyb20gcGFja2FnZS5qc29uIGlzIE5PVCBpbiBhcHBzIGZyb20gdGVtcGxhdGVcbiAgICAgICAgICAgICAgICBpZighKGNoZWNrS2V5RXhpc3RzKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNjaExhbWJkYUxvZ2dlci5sb2coJ0RlcGVuZGVuY3kgbm90IGZvdW5kIGluIHRlbXBsYXRlJywga2V5LCBpbnN0YWxsZXJEZXBlbmRlbmN5W2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lMaXN0LnB1c2goe1wibmFtZVwiOiBrZXksIFwidmVyc2lvblwiOiBpbnN0YWxsZXJEZXBlbmRlbmN5W2tleV0sIFwidGVtcGxhdGVcIjogXCItXCIsIFwicmVzdWx0XCI6IFwibWlzc2luZ1wifSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVja0tleUV4aXN0cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgZGVwZW5kZW5jeSBmcm9tIHBhY2thZ2UuanNvbiBpcyBpbiB0ZW1wbGF0ZSBcbiAgICAgICAgICAgICAgICAgICAgLy9pbmRleCBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIGRlcGVuZGVuY3kgZnJvbSBwYWNrYWdlLmpzb24gaW4gdGhlIGFwcHMgZnJvbSB0ZW1wbGF0ZSBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gZmluZEluZGV4T2ZLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBwb3NpdGlvbiBvZiBpbmRleCBpcyBhZnRlciBwb3NpdGlvbiBvZiBhcHAgaW4gdGVtcGxhdGUgY291bnQgYXMgbWlzc2luZyBkZXBlbmRlbmN5XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGluZGV4IDwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjaExhbWJkYUxvZ2dlci5sb2coYXBwc0Zyb21UZW1wbGF0ZVtpbmRleF1ba2V5XSwnIGFwcGVhcnMgaW4gdGVtcGxhdGUgYWZ0ZXInLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TGlzdC5wdXNoKHtcIm5hbWVcIjoga2V5LCBcInZlcnNpb25cIjogaW5zdGFsbGVyRGVwZW5kZW5jeVtrZXldLCBcInRlbXBsYXRlXCI6IGFwcHNGcm9tVGVtcGxhdGVbaW5kZXhdW2tleV0sIFwicmVzdWx0XCI6IFwib3JkZXIgZXJyb3JcIn0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2lmIGRlcGVuZGVuY3kgaXMgaW4gdGVtcGxhdGUgYW5kIGFwcGVhcnMgYmVmb3JlIGFwcCBpbiB0ZW1wbGF0ZSBjaGVjayBmb3Igc2VtYW50aWMgdmVyc2lvbmluZyBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYXRpc2ZpZXMoYXBwc0Zyb21UZW1wbGF0ZVtpbmRleF1ba2V5XSwgaW5zdGFsbGVyRGVwZW5kZW5jeVtrZXldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjY2hMYW1iZGFMb2dnZXIubG9nKCdkZXBlbmRlbmN5IGlzIGluIHRlbXBsYXRlIGFuZCBkb2VzIG5vdCBzYXRpc2Z5IHNlbWFudGljIHZlcnNpb25pbmcnLCBrZXksIGFwcHNGcm9tVGVtcGxhdGVbaW5kZXhdW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeUxpc3QucHVzaCh7XCJuYW1lXCI6IGtleSwgXCJ2ZXJzaW9uXCI6IGluc3RhbGxlckRlcGVuZGVuY3lba2V5XSwgXCJ0ZW1wbGF0ZVwiOiBhcHBzRnJvbVRlbXBsYXRlW2luZGV4XVtrZXldLCBcInJlc3VsdFwiOiBcInZlcnNpb24gZXJyb3JcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2F0aXNmaWVzKGFwcHNGcm9tVGVtcGxhdGVbaW5kZXhdW2tleV0sIGluc3RhbGxlckRlcGVuZGVuY3lba2V5XSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjY2hMYW1iZGFMb2dnZXIubG9nKCdkZXBlbmRlbmN5IGV4aXN0cyBhbmQgc2F0aXNmaWVzIHNlbXZlcicsIGFwcHNGcm9tVGVtcGxhdGVbaW5kZXhdW2tleV0sIGluc3RhbGxlckRlcGVuZGVuY3lba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeUxpc3QucHVzaCh7XCJuYW1lXCI6IGtleSwgXCJ2ZXJzaW9uXCI6IGluc3RhbGxlckRlcGVuZGVuY3lba2V5XSwgXCJ0ZW1wbGF0ZVwiOiBhcHBzRnJvbVRlbXBsYXRlW2luZGV4XVtrZXldLCBcInJlc3VsdFwiOiBcInBhc3NcIn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcHBGcm9tVGVtcGxhdGUgPSBPYmplY3Qua2V5cyhhcHBzRnJvbVRlbXBsYXRlW2ldKVxuICAgICAgICB0ZW1wbGF0ZVZhbGlkYXRpb24ucHVzaCh7XCJuYW1lXCIgOiBhcHBGcm9tVGVtcGxhdGVbMF0sIFwiZGVwZW5kZW5jaWVzXCI6IGRlcGVuZGVuY3lMaXN0fSlcbiAgICAgICAgLy8gTmVlZHMgdG8gYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtYXQgdG8gYmUgcHJvY2Vzc2VkIGJ5IFRPRiBjb3JyZWN0bHk6XG4gICAgICAgIC8vIFtcbiAgICAgICAgLy8gICAgIHtcbiAgICAgICAgLy8gICAgICAgICBcIm5hbWVcIjogXCJzYW1wbGUtYXBwXCIsXG4gICAgICAgIC8vICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIjogZGVwZW5kZW5jeUxpc3RcbiAgICAgICAgLy8gICAgIH0sXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgXCJuYW1lXCI6IFwic2FtcGxlLWFwcDJcIixcbiAgICAgICAgLy8gICAgICAgICBcImRlcGVuZGVuY2llc1wiOiBkZXBlbmRlbmN5TGlzdFxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyBdXG4gICAgICAgIFxuICAgIH0gXG4gICAgY2NoTGFtYmRhTG9nZ2VyLmxvZygnTWlzc2luZyBkZXBlbmRlbmNpZXMgYXJlJywgdGVtcGxhdGVWYWxpZGF0aW9uKSAgIFxuICAgIHJldHVybiB0ZW1wbGF0ZVZhbGlkYXRpb25cbn0iXX0=